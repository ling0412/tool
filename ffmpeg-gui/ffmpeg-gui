#!/usr/bin/env python3
import sys
import os
import subprocess
import json
import shlex
from PySide6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QLineEdit, QComboBox, QPushButton, QMessageBox, QCheckBox, 
    QGridLayout, QGroupBox, QSpinBox, QFileDialog, QDialog, QTextEdit, 
    QSizePolicy, QSpacerItem, QScrollArea
)
from PySide6.QtCore import Qt

# ===========================
# 常量定义
# ===========================
VIDEO_CODECS = ["libx264", "libx265", "libsvtav1", "h264_vaapi", "hevc_vaapi", 
                "av1_vaapi", "vp9_vaapi", "copy"]
AUDIO_CODECS = ["aac", "libmp3lame", "libvorbis", "libopus", "flac", "pcm_s16le", "copy"]
SW_PRESETS = ["medium", "ultrafast", "superfast", "veryfast", "fast", "slow", "veryslow"]
SVTAV1_PRESETS = {
    "8 (均衡)": 8, "0 (最快)": 0, "1": 1, "2": 2, "3": 3, "4": 4, 
    "5": 5, "6": 6, "7": 7, "9": 9, "10": 10, "11": 11, "12 (最慢)": 12
}

SW_RC_MODES = {
    "CRF (Constant Rate Factor)": {"rc_mode": "CRF", "params": ["crf"]},
    "CBR (Constant Bitrate)": {"rc_mode": "CBR", "params": ["bitrate"]},
    "VBR (Variable Bitrate)": {"rc_mode": "VBR", "params": ["bitrate"]}
}

VAAPI_RC_MODES = {
    "CQP (Constant QP)": {"rc_mode": "CQP", "params": ["qp_p"]},
    "CBR (Constant Bitrate)": {"rc_mode": "CBR", "params": ["bitrate"]},
    "VBR (Variable Bitrate)": {"rc_mode": "VBR", "params": ["bitrate"]},
    "ICQ (Intelligent CQ)": {"rc_mode": "ICQ", "params": ["qp_icq"]},
    "QVBR (Quality VBR)": {"rc_mode": "QVBR", "params": ["bitrate", "qp_icq"]},
    "AVBR (Average VBR)": {"rc_mode": "AVBR", "params": ["bitrate"]}
}

AUDIO_EXTENSIONS = ['.mp3', '.aac', '.flac', '.wav', '.ogg', '.m4a', '.opus']

OUTPUT_EXTENSIONS = {
    "libx264": ".mp4", "libx265": ".mp4", "libsvtav1": ".mkv",
    "h264_vaapi": ".mp4", "hevc_vaapi": ".mp4", "av1_vaapi": ".mp4",
    "vp9_vaapi": ".webm", "copy": ".mp4",
    "aac": ".mp3", "libmp3lame": ".mp3", "copy_audio": ".mp3"
}


# ===========================
# FFprobe 详情对话框
# ===========================
class FFprobeDetailsDialog(QDialog):
    """显示 ffprobe 详细信息的模态对话框"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("输入文件详细信息 (ffprobe)")
        self.setMinimumSize(850, 650)
        self._init_ui()
    
    def _init_ui(self):
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("ffprobe 返回的 JSON 数据:"))
        
        self.text_editor = QTextEdit()
        self.text_editor.setReadOnly(True)
        self.text_editor.setFontPointSize(10)
        self.text_editor.setStyleSheet("font-family: 'monospace';")
        layout.addWidget(self.text_editor)
        
        close_btn = QPushButton("关闭")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
    
    def set_content(self, content):
        """设置并显示格式化的 ffprobe 输出内容"""
        self.text_editor.setText(content)


# ===========================
# 主窗口类
# ===========================
class FFmpegGenerator(QWidget):
    
    def __init__(self, input_file_path=None):
        super().__init__()
        self.setWindowTitle("FFmpeg GUI")
        self.setMinimumWidth(900)
        
        # 初始化动态控件
        self._init_dynamic_widgets()
        
        # 构建 UI
        self._init_ui()
        
        # 绑定事件
        self._bind_events()
        
        # 设置初始输入文件
        if input_file_path and os.path.exists(input_file_path):
            self.input_path_input.setText(input_file_path)
            self._update_output_path(input_file_path)
        
        # 初始化状态
        self._handle_vcodec_change(self.vcodec_combo.currentText())
        self._handle_input_path_change(self.input_path_input.text())
        self._update_encoding_preview()
        self._update_metrics_preview()
    
    # ===========================
    # 初始化方法
    # ===========================
    
    def _init_dynamic_widgets(self):
        """初始化动态参数输入控件"""
        # CRF 控件
        self.crf_label = QLabel("CRF 值 (0-51):")
        self.crf_input = QSpinBox()
        self.crf_input.setRange(0, 51)
        self.crf_input.setValue(23)
        self.crf_input.setMaximumWidth(100)
        
        # QP 控件
        self.qp_label = QLabel("QP/ICQ 质量因子 (1-51):")
        self.qp_input = QSpinBox()
        self.qp_input.setRange(1, 51)
        self.qp_input.setValue(20)
        self.qp_input.setMaximumWidth(100)
        
        # 比特率控件
        self.bitrate_label = QLabel("目标码率 (-b:v, kbps):")
        self.bitrate_input = QSpinBox()
        self.bitrate_input.setRange(100, 20000)
        self.bitrate_input.setSingleStep(500)
        self.bitrate_input.setValue(4000)
        self.bitrate_input.setMaximumWidth(100)
    
    def _init_ui(self):
        """构建主界面"""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(20)
        
        # 添加编码模块
        main_layout.addWidget(self._create_encoding_section())
        
        # 添加质量分析模块
        main_layout.addWidget(self._create_metrics_section())

    def _create_encoding_section(self):
        """创建编码配置区域"""
        group = QGroupBox("编码配置")
        layout = QVBoxLayout(group)
        
        # 文件输入/输出
        layout.addWidget(self._create_file_group())
        
        # 编码器参数
        layout.addWidget(self._create_codec_group())
        
        # 命令预览
        layout.addLayout(self._create_command_preview("encoding"))
        
        # 执行按钮
        launch_btn = QPushButton("运行编码 FFmpeg 命令 (foot)")
        launch_btn.clicked.connect(lambda: self._execute_ffmpeg(
            self._generate_encoding_command(), "FFmpeg 编码日志"))
        layout.addWidget(launch_btn)
        
        return group
    
    def _create_file_group(self):
        """创建文件输入/输出组"""
        group = QGroupBox("输入/输出文件")
        layout = QGridLayout(group)
        
        # 主输入文件
        self.input_path_input = QLineEdit("input_file.mp4")
        input_btn = QPushButton("选择...")
        self.ffprobe_btn = QPushButton("详细信息")
        self.ffprobe_btn.setEnabled(False)
        
        input_btn.clicked.connect(lambda: self._open_file_dialog(
            self.input_path_input, is_save_dialog=False))
        
        layout.addWidget(QLabel("主输入文件 (-i):"), 0, 0)
        layout.addWidget(self.input_path_input, 0, 1)
        layout.addWidget(input_btn, 0, 2)
        layout.addWidget(self.ffprobe_btn, 0, 3)
        
        # 额外输入文件（用于字幕等）
        self.extra_input_input = QLineEdit()
        self.extra_input_input.setPlaceholderText("可选，例如: 字幕文件 .srt / .ass")
        extra_input_btn = QPushButton("选择...")
        extra_input_btn.clicked.connect(lambda: self._open_file_dialog(
            self.extra_input_input, is_save_dialog=False))
        
        layout.addWidget(QLabel("额外输入文件 (-i):"), 1, 0)
        layout.addWidget(self.extra_input_input, 1, 1)
        layout.addWidget(extra_input_btn, 1, 2)
        
        # 输出文件
        self.output_path_input = QLineEdit("output.mp4")
        output_btn = QPushButton("选择...")
        output_btn.clicked.connect(lambda: self._open_file_dialog(
            self.output_path_input, is_save_dialog=True))
        
        layout.addWidget(QLabel("输出文件路径:"), 2, 0)
        layout.addWidget(self.output_path_input, 2, 1)
        layout.addWidget(output_btn, 2, 2)
        
        return group
    
    def _create_codec_group(self):
        """创建编码器参数组"""
        group = QGroupBox("编码器与参数")
        layout = QGridLayout(group)
        
        row = 0
        
        # 视频编码器
        self.vcodec_combo = QComboBox()
        self.vcodec_combo.addItems(VIDEO_CODECS)
        self.vcodec_combo.setCurrentText("libsvtav1")
        self.vcodec_label = QLabel("视频编码器 (-c:v):")
        
        layout.addWidget(self.vcodec_label, row, 0)
        layout.addWidget(self.vcodec_combo, row, 1)
        row += 1
        
        # RC 模式
        self.rc_mode_combo = QComboBox()
        self.rc_mode_label = QLabel("码率控制模式:")
        
        layout.addWidget(self.rc_mode_label, row, 0)
        layout.addWidget(self.rc_mode_combo, row, 1)
        row += 1
        
        # RC 参数容器
        self.rc_params_widget = QWidget()
        self.rc_params_layout = QGridLayout(self.rc_params_widget)
        self.rc_params_layout.setContentsMargins(0, 0, 0, 0)
        
        layout.addWidget(self.rc_params_widget, row, 0, 1, 2)
        row += 1
        
        # 编码预设
        self.quality_preset_combo = QComboBox()
        self.quality_preset_label = QLabel("编码预设 (-preset):")
        
        layout.addWidget(self.quality_preset_label, row, 0)
        layout.addWidget(self.quality_preset_combo, row, 1)
        row += 1
        
        # VAAPI 设备
        self.vaapi_device_input = QLineEdit("/dev/dri/renderD128")
        self.vaapi_label = QLabel("VAAPI 设备路径:")
        
        layout.addWidget(self.vaapi_label, row, 0)
        layout.addWidget(self.vaapi_device_input, row, 1)
        row += 1
        
        # 线程数
        self.threads_input = QSpinBox()
        self.threads_input.setRange(0, 32)
        self.threads_input.setValue(12)
        self.threads_input.setMaximumWidth(100)
        self.threads_label = QLabel("编码线程数 (-threads):")
        
        layout.addWidget(self.threads_label, row, 0)
        layout.addWidget(self.threads_input, row, 1, Qt.AlignmentFlag.AlignLeft)
        row += 1
        
        # 音频编码器
        self.acodec_combo = QComboBox()
        self.acodec_combo.addItems(AUDIO_CODECS)
        self.acodec_combo.setCurrentText("libopus")
        
        layout.addWidget(QLabel("音频编码器 (-c:a):"), row, 0)
        layout.addWidget(self.acodec_combo, row, 1)
        row += 1
        
        # 音频比特率
        self.audio_bitrate_input = QSpinBox()
        self.audio_bitrate_input.setRange(32, 512)
        self.audio_bitrate_input.setSingleStep(32)
        self.audio_bitrate_input.setValue(192)
        self.audio_bitrate_input.setMaximumWidth(100)
        
        layout.addWidget(QLabel("音频比特率 (kbps):"), row, 0)
        layout.addWidget(self.audio_bitrate_input, row, 1, Qt.AlignmentFlag.AlignLeft)
        row += 1
        
        # 额外 FFmpeg 参数
        self.extra_args_input = QLineEdit("-map 0:v:0 -map 0:a:0")
        self.extra_args_input.setPlaceholderText("例如: -map 0:v:0 -map 0:a:0 -map 1:s:0")
        
        layout.addWidget(QLabel("额外 FFmpeg 参数:"), row, 0)
        layout.addWidget(self.extra_args_input, row, 1)
        
        return group
    
    def _create_command_preview(self, preview_type):
        """创建命令预览区域"""
        hbox = QHBoxLayout()
        
        if preview_type == "encoding":
            self.encoding_preview_label = QLabel("编码 FFmpeg 命令:")
            self.encoding_preview_label.setFrameShape(QLabel.Shape.StyledPanel)
            self.encoding_preview_label.setFrameShadow(QLabel.Shadow.Sunken)
            self.encoding_preview_label.setWordWrap(True)
            self.encoding_preview_label.setContentsMargins(10, 10, 10, 10)
            
            copy_btn = QPushButton("复制命令")
            copy_btn.clicked.connect(lambda: self._copy_command(
                self._generate_encoding_command()))
            copy_btn.setMaximumWidth(100)
            
            hbox.addWidget(self.encoding_preview_label)
            hbox.addWidget(copy_btn, alignment=Qt.AlignmentFlag.AlignTop)
        
        else:  # metrics
            self.metrics_preview_label = QLabel("分析 FFmpeg 命令:")
            self.metrics_preview_label.setFrameShape(QLabel.Shape.StyledPanel)
            self.metrics_preview_label.setFrameShadow(QLabel.Shadow.Sunken)
            self.metrics_preview_label.setWordWrap(True)
            self.metrics_preview_label.setContentsMargins(10, 10, 10, 10)
            
            copy_btn = QPushButton("复制命令")
            copy_btn.clicked.connect(lambda: self._copy_command(
                self._generate_metrics_command()))
            copy_btn.setMaximumWidth(100)
            
            hbox.addWidget(self.metrics_preview_label)
            hbox.addWidget(copy_btn, alignment=Qt.AlignmentFlag.AlignTop)
        
        return hbox
    
    def _create_metrics_section(self):
        """创建质量分析区域"""
        group = QGroupBox("质量分析：VMAF / PSNR / SSIM")
        layout = QVBoxLayout(group)
        
        # 文件选择
        file_layout = QGridLayout()
        
        # 参考文件
        self.ref_path_input = QLineEdit("original.mp4")
        ref_btn = QPushButton("选择...")
        ref_btn.clicked.connect(lambda: self._open_file_dialog(
            self.ref_path_input, is_save_dialog=False))
        
        file_layout.addWidget(QLabel("参考文件 (Reference):"), 0, 0)
        file_layout.addWidget(self.ref_path_input, 0, 1)
        file_layout.addWidget(ref_btn, 0, 2)
        
        # 失真文件
        self.distorted_path_input = QLineEdit("encoded.mp4")
        distorted_btn = QPushButton("选择...")
        distorted_btn.clicked.connect(lambda: self._open_file_dialog(
            self.distorted_path_input, is_save_dialog=False))
        
        file_layout.addWidget(QLabel("失真文件 (Distorted):"), 1, 0)
        file_layout.addWidget(self.distorted_path_input, 1, 1)
        file_layout.addWidget(distorted_btn, 1, 2)
        
        layout.addLayout(file_layout)
        
        # 指标选择
        metrics_hbox = QHBoxLayout()
        metrics_hbox.addWidget(QLabel("选择指标:"))
        
        self.vmaf_checkbox = QCheckBox("VMAF")
        self.vmaf_checkbox.setChecked(True)
        self.psnr_checkbox = QCheckBox("PSNR")
        self.ssim_checkbox = QCheckBox("SSIM")
        
        metrics_hbox.addWidget(self.vmaf_checkbox)
        metrics_hbox.addWidget(self.psnr_checkbox)
        metrics_hbox.addWidget(self.ssim_checkbox)
        metrics_hbox.addStretch(1)
        
        layout.addLayout(metrics_hbox)
        
        # 命令预览
        layout.addLayout(self._create_command_preview("metrics"))
        
        # 执行按钮
        launch_btn = QPushButton("运行质量分析 FFmpeg 命令 (foot)")
        launch_btn.clicked.connect(lambda: self._execute_ffmpeg(
            self._generate_metrics_command(), "FFmpeg 质量分析日志"))
        layout.addWidget(launch_btn)
        
        return group
    
    # ===========================
    # 事件绑定
    # ===========================
    
    def _bind_events(self):
        """绑定所有输入组件的更改事件"""
        # 输入文件相关
        self.input_path_input.textChanged.connect(self._handle_input_path_change)
        self.extra_input_input.textChanged.connect(self._update_encoding_preview)
        self.ffprobe_btn.clicked.connect(self._show_ffprobe_details)
        self.output_path_input.textChanged.connect(self._update_encoding_preview)
        
        # 编码器相关
        self.vcodec_combo.currentTextChanged.connect(self._handle_vcodec_change)
        self.vcodec_combo.currentTextChanged.connect(self._update_output_path)
        self.vcodec_combo.currentTextChanged.connect(self._update_encoding_preview)
        
        self.acodec_combo.currentTextChanged.connect(self._update_encoding_preview)
        self.rc_mode_combo.currentTextChanged.connect(self._handle_rc_mode_change)
        self.quality_preset_combo.currentTextChanged.connect(self._update_encoding_preview)
        
        # 参数相关
        self.crf_input.valueChanged.connect(self._update_encoding_preview)
        self.qp_input.valueChanged.connect(self._update_encoding_preview)
        self.bitrate_input.valueChanged.connect(self._update_encoding_preview)
        self.vaapi_device_input.textChanged.connect(self._update_encoding_preview)
        self.threads_input.valueChanged.connect(self._update_encoding_preview)
        self.audio_bitrate_input.valueChanged.connect(self._update_encoding_preview)
        self.extra_args_input.textChanged.connect(self._update_encoding_preview)
        
        # 质量分析相关
        self.ref_path_input.textChanged.connect(self._update_metrics_preview)
        self.distorted_path_input.textChanged.connect(self._update_metrics_preview)
        self.vmaf_checkbox.stateChanged.connect(self._update_metrics_preview)
        self.psnr_checkbox.stateChanged.connect(self._update_metrics_preview)
        self.ssim_checkbox.stateChanged.connect(self._update_metrics_preview)
    
    # ===========================
    # 工具方法
    # ===========================
    
    def _is_audio_file(self, path):
        """判断是否为纯音频文件"""
        if not path:
            return False
        ext = os.path.splitext(path.lower())[1]
        return ext in AUDIO_EXTENSIONS
    
    def _open_file_dialog(self, line_edit, is_save_dialog=False):
        """打开文件对话框"""
        default_filter = ("Video Files (*.mp4 *.mkv *.avi *.webm);;"
                         "Audio Files (*.mp3 *.aac *.flac *.wav *.m4a);;"
                         "Subtitle Files (*.srt *.ass *.ssa);;"
                         "All Files (*.*)")
        
        if is_save_dialog:
            path, _ = QFileDialog.getSaveFileName(
                self, "保存文件为", line_edit.text(), default_filter)
        else:
            path, _ = QFileDialog.getOpenFileName(
                self, "选择文件", line_edit.text(), default_filter)
        
        if path:
            line_edit.setText(path)
            if line_edit == self.input_path_input:
                self._update_output_path(path)
    
    def _update_output_path(self, input_path=None):
        """根据输入路径自动生成输出路径"""
        if input_path is None:
            input_path = self.input_path_input.text()
        
        if not input_path:
            self.output_path_input.setText("output.mp4")
            return
        
        dir_name = os.path.dirname(input_path)
        base_name = os.path.splitext(os.path.basename(input_path))[0]
        
        if self._is_audio_file(input_path):
            target_ext = OUTPUT_EXTENSIONS.get(self.acodec_combo.currentText(), ".mp3")
        else:
            target_ext = OUTPUT_EXTENSIONS.get(self.vcodec_combo.currentText(), ".mp4")
        
        output_path = os.path.join(dir_name, f"{base_name}_encoded{target_ext}")
        self.output_path_input.setText(output_path)
    
    def _copy_command(self, command_list):
        """将命令列表复制到剪贴板"""
        clipboard = QApplication.clipboard()
        command_str = " ".join(shlex.quote(p) for p in command_list)
        clipboard.setText(command_str)
        QMessageBox.information(self, "成功", "命令已复制到剪贴板")
    
    # ===========================
    # 事件处理器
    # ===========================
    
    def _handle_input_path_change(self, path):
        """处理输入文件路径变化"""
        is_audio_only = self._is_audio_file(path)
        
        # 控制 ffprobe 按钮
        self.ffprobe_btn.setEnabled(bool(path.strip()))
        
        # 控制视频相关选项
        self._set_video_options_enabled(not is_audio_only)
        
        self._update_encoding_preview()
    
    def _set_video_options_enabled(self, enabled):
        """启用或禁用视频相关控件"""
        self.vcodec_combo.setEnabled(enabled)
        self.vcodec_label.setEnabled(enabled)
        self.rc_mode_combo.setEnabled(enabled)
        self.rc_mode_label.setEnabled(enabled)
        self.rc_params_widget.setEnabled(enabled)
        self.quality_preset_combo.setEnabled(enabled)
        self.quality_preset_label.setEnabled(enabled)
        self.vaapi_label.setEnabled(enabled)
        
        if not enabled:
            self.vaapi_device_input.setEnabled(False)
        else:
            self._handle_vcodec_change(self.vcodec_combo.currentText())
    
    def _handle_vcodec_change(self, vcodec):
        """处理视频编码器变化"""
        if not self.vcodec_combo.isEnabled():
            return
        
        is_vaapi = "vaapi" in vcodec
        is_copy = vcodec == "copy"
        is_software = not is_vaapi and not is_copy
        
        # VAAPI 设备
        self.vaapi_device_input.setEnabled(is_vaapi)
        
        # 编码预设
        self._update_preset_options(vcodec, is_software)
        
        # RC 模式
        self._update_rc_mode_options(vcodec, is_vaapi, is_copy)
    
    def _update_preset_options(self, vcodec, is_software):
        """更新编码预设选项"""
        self.quality_preset_combo.blockSignals(True)
        self.quality_preset_combo.clear()
        
        self.quality_preset_combo.setEnabled(is_software)
        self.quality_preset_label.setEnabled(is_software)
        
        if is_software:
            if vcodec == "libsvtav1":
                self.quality_preset_combo.addItems(SVTAV1_PRESETS.keys())
                self.quality_preset_combo.setCurrentText("8 (均衡)")
                self.quality_preset_label.setText("SVT-AV1 预设 (0-12):")
            else:
                self.quality_preset_combo.addItems(SW_PRESETS)
                self.quality_preset_combo.setCurrentText("medium")
                self.quality_preset_label.setText("编码预设 (-preset):")
        else:
            self.quality_preset_combo.addItem("N/A (非软件编码)")
        
        self.quality_preset_combo.blockSignals(False)
    
    def _update_rc_mode_options(self, vcodec, is_vaapi, is_copy):
        """更新码率控制模式选项"""
        self.rc_mode_combo.blockSignals(True)
        self.rc_mode_combo.clear()
        
        is_audio = self._is_audio_file(self.input_path_input.text())
        self.rc_mode_combo.setEnabled(not is_copy and not is_audio)
        
        if is_copy:
            self.rc_mode_combo.addItem("N/A (复制模式)")
        elif is_vaapi:
            self.rc_mode_label.setText("VAAPI 码率控制:")
            for label in VAAPI_RC_MODES.keys():
                self.rc_mode_combo.addItem(label)
            
            default_mode = ("ICQ (Intelligent CQ)" if vcodec == "h264_vaapi" 
                           else "CQP (Constant QP)")
            if self.rc_mode_combo.findText(default_mode) != -1:
                self.rc_mode_combo.setCurrentText(default_mode)
        else:
            self.rc_mode_label.setText("软件码率控制:")
            for label in SW_RC_MODES.keys():
                self.rc_mode_combo.addItem(label)
            self.rc_mode_combo.setCurrentText("CRF (Constant Rate Factor)")
        
        self.rc_mode_combo.blockSignals(False)
        self._handle_rc_mode_change(self.rc_mode_combo.currentText())
    
    def _handle_rc_mode_change(self, mode_label):
        """处理码率控制模式变化"""
        # 清除现有控件
        for i in reversed(range(self.rc_params_layout.count())):
            widget = self.rc_params_layout.itemAt(i).widget()
            if widget:
                widget.setParent(None)
        
        is_vaapi = "vaapi" in self.vcodec_combo.currentText()
        mode_data = (VAAPI_RC_MODES.get(mode_label) if is_vaapi 
                    else SW_RC_MODES.get(mode_label))
        
        if not mode_data:
            self._update_encoding_preview()
            return
        
        params = mode_data.get("params", [])
        row = 0
        
        if "crf" in params:
            self.rc_params_layout.addWidget(self.crf_label, row, 0, 
                                           Qt.AlignmentFlag.AlignRight)
            self.rc_params_layout.addWidget(self.crf_input, row, 1, 
                                           Qt.AlignmentFlag.AlignLeft)
            row += 1
        
        if "qp_p" in params or "qp_icq" in params:
            self.rc_params_layout.addWidget(self.qp_label, row, 0, 
                                           Qt.AlignmentFlag.AlignRight)
            self.rc_params_layout.addWidget(self.qp_input, row, 1, 
                                           Qt.AlignmentFlag.AlignLeft)
            row += 1
        
        if "bitrate" in params:
            self.rc_params_layout.addWidget(self.bitrate_label, row, 0, 
                                           Qt.AlignmentFlag.AlignRight)
            self.rc_params_layout.addWidget(self.bitrate_input, row, 1, 
                                           Qt.AlignmentFlag.AlignLeft)
            row += 1
        
        if row > 0:
            self.rc_params_layout.addItem(
                QSpacerItem(20, 10, QSizePolicy.Policy.Minimum, 
                           QSizePolicy.Policy.Expanding), row, 0)
        
        self._update_encoding_preview()
    
    # ===========================
    # FFprobe 功能
    # ===========================
    
    def _show_ffprobe_details(self):
        """显示 ffprobe 详细信息"""
        input_path = self.input_path_input.text().strip()
        
        if not input_path:
            QMessageBox.warning(self, "警告", "请先指定一个输入文件路径。")
            return
        
        ffprobe_cmd = [
            "ffprobe", "-v", "quiet", "-print_format", "json",
            "-show_format", "-show_streams", input_path
        ]
        
        try:
            result = subprocess.run(
                ffprobe_cmd, capture_output=True, text=True, 
                check=True, encoding='utf-8'
            )
            
            try:
                data = json.loads(result.stdout)
                formatted_json = json.dumps(data, indent=4, ensure_ascii=False)
            except json.JSONDecodeError:
                formatted_json = f"FFprobe 原始输出:\n\n{result.stdout}"
            
            dialog = FFprobeDetailsDialog(self)
            dialog.set_content(formatted_json)
            dialog.exec()
            
        except subprocess.CalledProcessError as e:
            error_msg = f"FFprobe 失败:\n\n{e.stderr.strip()}"
            QMessageBox.critical(self, "FFprobe 错误", error_msg)
        except FileNotFoundError:
            QMessageBox.critical(
                self, "执行失败", 
                "找不到 'ffprobe' 命令。请确保 FFmpeg 已安装。"
            )
        except Exception as e:
            QMessageBox.critical(self, "错误", f"发生意外错误: {e}")
    
    # ===========================
    # 命令生成
    # ===========================
    
    def _generate_encoding_command(self):
        """生成 FFmpeg 编码命令"""
        command = ["ffmpeg", "-hide_banner"]
        
        input_path = self.input_path_input.text().strip()
        extra_input = self.extra_input_input.text().strip()
        is_audio_only = self._is_audio_file(input_path)
        vcodec = self.vcodec_combo.currentText()
        
        # VAAPI 设备（必须在 -i 之前）
        vaapi_active = "vaapi" in vcodec and not is_audio_only
        if vaapi_active:
            vaapi_device = self.vaapi_device_input.text().strip()
            if vaapi_device:
                command.extend(["-vaapi_device", vaapi_device])
        
        # 主输入文件
        if input_path:
            command.extend(["-i", input_path])
        
        # 额外输入文件（字幕等）
        if extra_input:
            command.extend(["-i", extra_input])
        
        # 视频滤镜（VAAPI 上传）
        if vaapi_active:
            command.extend(["-vf", "format=nv12,hwupload"])
        
        # 视频编码参数
        if not is_audio_only and vcodec != "copy":
            command.extend(["-c:v", vcodec])
            
            rc_mode_label = self.rc_mode_combo.currentText()
            is_vaapi = "vaapi" in vcodec
            mode_data = (VAAPI_RC_MODES.get(rc_mode_label) if is_vaapi 
                        else SW_RC_MODES.get(rc_mode_label))
            
            if mode_data:
                self._add_rc_params(command, mode_data, is_vaapi)
            
            # 编码预设
            if not is_vaapi:
                self._add_preset_params(command, vcodec)
        
        elif vcodec == "copy" and not is_audio_only:
            command.extend(["-c:v", "copy"])
        
        # 音频编码参数
        acodec = self.acodec_combo.currentText()
        if acodec:
            command.extend(["-c:a", acodec])
            
            audio_bitrate = self.audio_bitrate_input.value()
            if audio_bitrate > 0 and acodec != "copy":
                command.extend(["-b:a", f"{audio_bitrate}k"])
        
        # 线程数
        threads = self.threads_input.value()
        if threads > 0:
            command.extend(["-threads", str(threads)])
        
        # 额外参数
        extra_args = self.extra_args_input.text().strip()
        if extra_args:
            try:
                command.extend(shlex.split(extra_args))
            except ValueError:
                pass
        
        # 输出文件
        output_path = self.output_path_input.text().strip()
        if output_path:
            command.append(output_path)
        
        return [part for part in command if part]
    
    def _add_rc_params(self, command, mode_data, is_vaapi):
        """添加码率控制参数"""
        rc_mode = mode_data.get("rc_mode", "")
        params = mode_data.get("params", [])
        
        if is_vaapi:
            if rc_mode:
                command.extend(["-rc_mode", rc_mode])
            
            for param in params:
                if param in ["qp_p", "qp_icq"]:
                    command.extend(["-qp", str(self.qp_input.value())])
                elif param == "bitrate":
                    bitrate = self.bitrate_input.value()
                    command.extend(["-b:v", f"{bitrate}k"])
                    command.extend(["-maxrate", f"{int(bitrate * 1.2)}k"])
        else:
            if "crf" in params:
                command.extend(["-crf", str(self.crf_input.value())])
            if "bitrate" in params:
                command.extend(["-b:v", f"{self.bitrate_input.value()}k"])
    
    def _add_preset_params(self, command, vcodec):
        """添加编码预设参数"""
        preset_label = self.quality_preset_combo.currentText()
        if not preset_label or "N/A" in preset_label:
            return
        
        if vcodec == "libsvtav1":
            preset_value = SVTAV1_PRESETS.get(preset_label)
            if preset_value is not None:
                command.extend(["-preset", str(preset_value)])
            else:
                command.extend(["-preset", "8"])
        else:
            command.extend(["-preset", preset_label])
    
    def _generate_metrics_command(self):
        """生成质量分析命令"""
        ref_path = self.ref_path_input.text().strip()
        dist_path = self.distorted_path_input.text().strip()
        
        if not ref_path or not dist_path:
            return ["echo", "错误: 请指定参考文件和失真文件"]
        
        filter_parts = []
        if self.vmaf_checkbox.isChecked():
            filter_parts.append("libvmaf=log_path=vmaf_log.json:log_fmt=json")
        if self.psnr_checkbox.isChecked():
            filter_parts.append("psnr")
        if self.ssim_checkbox.isChecked():
            filter_parts.append("ssim")
        
        if not filter_parts:
            return ["echo", "错误: 请至少选择一个质量指标"]
        
        filter_complex = ";".join([f"[0:v][1:v]{f}" for f in filter_parts])
        
        return [
            "ffmpeg", "-hide_banner",
            "-i", dist_path,
            "-i", ref_path,
            "-lavfi", filter_complex,
            "-f", "null", "-"
        ]
    
    # ===========================
    # 预览更新
    # ===========================
    
    def _update_encoding_preview(self):
        """更新编码命令预览"""
        command_list = self._generate_encoding_command()
        command_str = " ".join(shlex.quote(p) for p in command_list)
        
        preview_text = f"编码 FFmpeg 命令:\n\n<pre>{command_str}</pre>"
        self.encoding_preview_label.setText(preview_text)
        self.encoding_preview_label.setTextFormat(Qt.TextFormat.RichText)
    
    def _update_metrics_preview(self):
        """更新质量分析命令预览"""
        command_list = self._generate_metrics_command()
        command_str = " ".join(shlex.quote(p) for p in command_list)
        
        preview_text = f"分析 FFmpeg 命令:\n\n<pre>{command_str}</pre>"
        self.metrics_preview_label.setText(preview_text)
        self.metrics_preview_label.setTextFormat(Qt.TextFormat.RichText)
    
    # ===========================
    # 命令执行
    # ===========================
    
    def _execute_ffmpeg(self, command_list, title):
        """通过 foot 终端执行 FFmpeg 命令"""
        if not command_list or command_list[0] == "echo":
            error_msg = (" ".join(command_list[1:]) if len(command_list) > 1 
                        else "生成的 FFmpeg 命令不完整。")
            QMessageBox.warning(self, "错误", error_msg)
            return
        
        bash_script = f"""
echo "--- 正在准备运行 FFmpeg 命令 ---"
printf "执行: "
printf "%q " "$@"
echo
echo "-------------------------------------"

"$@"
STATUS=$?

echo
echo "-------------------------------------"
echo "--- 任务完成 (退出代码: $STATUS) ---"
if [ $STATUS -ne 0 ]; then
    echo "警告: FFmpeg 运行失败，请检查上方日志。"
fi
read -r -p "按任意键退出..."
"""
        
        foot_cmd = [
            "foot", "-T", title,
            "-e", "bash", "-c", bash_script, "bash"
        ] + command_list
        
        try:
            subprocess.Popen(foot_cmd)
        except FileNotFoundError as e:
            missing_cmd = str(e).split("'")[1] if "'" in str(e) else "foot/ffmpeg"
            QMessageBox.critical(
                self, "执行失败", 
                f"找不到命令: '{missing_cmd}'。\n"
                "请确保 foot 和 ffmpeg 已安装。"
            )
        except Exception as e:
            QMessageBox.critical(self, "启动失败", f"启动过程中发生错误: {e}")


# ===========================
# 主程序入口
# ===========================
def main():
    app = QApplication(sys.argv)
    
    # 设置工作目录
    if getattr(sys, 'frozen', False):
        application_path = os.path.dirname(sys.executable)
    else:
        application_path = os.path.dirname(os.path.abspath(__file__))
    
    os.chdir(application_path)
    
    # 获取命令行参数中的输入文件
    input_file = sys.argv[1] if len(sys.argv) > 1 else None
    
    # 创建并显示主窗口
    window = FFmpegGenerator(input_file_path=input_file)
    window.show()
    
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
